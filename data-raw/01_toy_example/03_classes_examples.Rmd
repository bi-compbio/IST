---
title: "Examples of IST objects"
author: "Sergio Picart-Armada"
date: "23rd Oct, 2023"
output:
  html_document:
    toc: TRUE
    toc_float: true
    code_folding: hide
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE, message = FALSE, error = FALSE, 
    fig.width = 7, fig.height = 6)
```

# Getting started

## Libraries

```{r libs}
library(methods)
library(ggplot2)
library(pcaMethods)

library(magrittr)
library(plyr)
library(dplyr)

# library(IST)
devtools::load_all()

set.seed(1)

dir.out <- "03_data"
if (!dir.exists(dir.out)) dir.create(dir.out)

# orthology mappings
data("data.list.orth")
# gene labels
data("vec.ensembl2symbol")
```

Note: this code is loosely based on that of the vignette.

# Classes overview

The newest implementation relies on three classes, each one with a purpose:

* `ist.signatures`: store a collection of signatures
* `ist.pathways`: store oc/bin models for a collection of pathways
* `ist.results`: apply an `ist.signatures` object 
into the `ist.pathways` models and display the outcomes 
(boxplots, heatmaps)

Also, there are built-in data objects that can ease the process:

* `data.list.orth`: orthology mapppings from rat, mouse and human to human
* `vec.ensembl2symbol`: readable and unique gene labels in the genemaps

## Signature collections

To handle several datasets with a single object, 
the `ist.signatures` class stores signatures, 
metadata and orthology mappings, 
possibly with multiple species.

First, the data must accomodate the input format for the list of signature

```{r}
list.sig <- lapply(
    split(sample.data.ist$dt.fc.mmu, 
          sample.data.ist$dt.fc.mmu$sig.id), 
    function(dt) {
        tab <- as.data.frame(dt[, c("logFC", "adj.P.Val")])
        rownames(tab) <- dt$gene.id
        
        tab
    }
)

head(list.sig$Signature1)
```

And for the metadata, which must contain the columns `sig.id` 
(coincident with the names in the list of signatures), `sig.name` 
(still unused) and 
`sig.org` (organism, concordant with the names of the orthology mapping list)

Here, we must include two extra columns if we want to use the interactive app

* `sig.class`: default, positivecontrol, or something else
* `study.id`: anything, for fill colors in the boxplot

```{r}
meta.sig <- mutate(
    sample.data.ist$df.meta.mmu, 
    sig.id = as.character(sig.id), 
    sig.org = as.character(sig.org), 
    sig.name = sig.id, 
    # recycle vector
    sig.class = rep(c("default", "newData"), length(sig.id)/2), 
    study.id = rep(c("study1", "study2"), each = length(sig.id)/2)
)

meta.sig
```

The orthology mapping must be ready, as provided in the precomputed data 
or as generated by `orthIDcon()`:

```{r}
list.orth <- data.list.orth["mmusculus"]

head(list.orth$mmusculus)
```

The `ist.signatures` object must be define and fitted.
Showing it will display a graphical summary of its contents.

```{r}
ist.sig <- define(
    "ist.signatures", 
    list.sig = list.sig, 
    tab.meta = meta.sig,
    org.to = "hsapiens",
    list.mapping = list.orth
) %>% fit

ist.sig
```

## Pathway models (includes oc/bin)

IST needs to know which samples are used to fit the models, 
to in silico treat and which samples look like the ideal output.

```{r}
# use all the samples to fit one-class and binary models
id.oc <- rep(TRUE, nrow(sample.data.ist$X.hsa))
id.bin <- rep(TRUE, nrow(sample.data.ist$X.hsa))

# in silico treat the controls
id.ist <- sample.data.ist$y.hsa == -1
# they should look like disease
id.ref <- sample.data.ist$y.hsa == 1
```

There is a dedicated class `ist.pathways` for 
pathway models (including one-class and
binary models).
It stores the pathways and the oc/bin models fitted on them.

For illustrative purposes, we are going to use the dummy pathways in the 
example data; they are not actually related with how the data was 
generated.

Importantly: if we want to later use the interactive app, we need to add
pathway metadata. A data.frame containing the following columns:

* `path.id`: as in the pathway data frame
* `path.class`: default, or something else 

```{r}
path.df <- sample.data.ist$path.hsa.oc %>% head(100)
path.list <- unique(path.df$path.id)

path.meta <- data.frame(
    path.id = path.list, 
    # recycle vector
    path.class = c("default", "toInvestigate")
)
```


```{r}
ist.path <- define(
    "ist.pathways",
    X = sample.data.ist$X, 
    y = sample.data.ist$y, 
    org.to = "hsapiens", 
    id.oc = id.oc, 
    id.bin = id.bin, 
    pathways.table.oc = path.df, 
    pathways.table.bin = path.df, 
    pathways.meta = path.meta
) %>% fit

ist.path
```


## Results object

There is a convenient `ist.results` class that applies all the signatures in
`ist.signatures` and predicts per pathway on an `ist.pathways` object.
One also has to specify which samples to in silico treat (`id.ist`) and 
which reference group these should ideally resemple (`id.ref`).

```{r}
ist.res <- define(
    "ist.results", 
    ist.signatures = ist.sig, 
    ist.pathways = ist.path, 
    id.ref = id.ref, 
    id.ist = id.ist, 
    vec.gene2label = vec.ensembl2symbol
) %>% fit

ist.res
```

The `ist.results` contains data tables to reproduce boxplots and heatmaps
that display the recovery by pathway, keeping an eye on the reference human 
data without any transformation.

### Boxplots

By default plots the first 4 pathways, but the behaviour can be changed.
Aesthetics on the signature metadata are allowed using `mapping = aes()`
and rows can be facetted by using `facet_rows = vars()`

```{r}
plot.ist.boxplots(
    ist.res, 
    mapping = aes(fill = sig.attr1), 
    facet_rows = vars(sig.attr2))
```

### Gene heatmaps

Gene heatmaps display the recovery of individual genes within a pathway.
Their sum is the total pathway recovery, as shown in the boxplots.
The user must specify which pathway to represent.
With the `type` argument, one can choose either ggplot or pheatmap plots.


The heatmaps can also be clustered by columns and by rows,
changing `args.pheatmap`:

```{r}
args.gmap <- list(cluster_rows = FALSE, cluster_cols = TRUE)

plot.ist.genemaps(
    ist.res, y = head(getPathways(ist.res), 1), 
    type = "pheatmap", 
    vars.meta.sig = c("sig.attr1", "sig.attr3"), 
    args.pheatmap = args.gmap)
```

### Pathway heatmaps

Pathway heatmaps summarise the whole pathway recovery over signatures, 
providing the overall picture of IST.
These can also use `pheatmap`, subset pathways and signatures.

```{r, fig.width=5, fig.height=4}
args.pmap <- default.args.pheatmap("pathwaymap")
args.pmap$cluster_rows <- args.pmap$cluster_cols <- TRUE

plot.ist.pathwaymaps(
    ist.res, 
    type = "pheatmap", 
    vars.meta.sig = c("sig.attr1", "sig.attr3"), 
    args.pheatmap = args.pmap)
```

Export the `ist.res` object

```{r}
sample.results.ist <- ist.res
save(sample.results.ist, file = paste0(dir.out, "/sample.results.ist.RData"), compress = "xz")
saveRDS(sample.results.ist, file = paste0(dir.out, "/sample.results.ist.rds"), compress = "xz")
```


# Reproducibility

```{r date}
date()
```

```{r rsession}
sessionInfo()
```

